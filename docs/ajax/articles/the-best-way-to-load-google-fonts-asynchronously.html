{
  "title": "The Best Way To Load Google Fonts Asynchronously",
  "content": "<div class=\"container\">\n  <div class=\"row\">\n    <div class=\"col\">\n\n<h1 id=\"the-best-way-to-load-google-fonts-asynchronously\">The Best Way To Load Google Fonts Asynchronously</h1>\n\n<p class=\"H1Lead lead\">\n  &gt; Part II of <em>Advanced Google Font</em>. Go to Part I: <a href=\"how-to-load-google-fonts-asynchronously.html\">How To Load Google Fonts Asynchronously</a> and Part III: <a href=\"embedding-critical-path-fonts.html\">Embedding Critical Path Fonts</a>.\n</p>\n\n<div class=\"row mb-3\">\n  <div class=\"col-2 col-sm-2 col-lg-1\">\n    <img alt=\"anton photo\"\n      src=\"data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' width='100' height='100'/%3E\" data-io class=\"rounded img-fluid\" data-src=\"avatar/anton.JPG\">\n    <noscript><img alt=\"anton photo\" class=\"rounded img-fluid\" src=\"avatar/anton.JPG\"></noscript>\n  </div>\n  <div style=\"border-bottom: 1px solid grey;\" class=\"col-10 col-sm-7\">\n    <p class=\"text-right\" style=\"color: grey;\">\n      <span>Anton Dmukhovskiy, Senior Software Developer</span><br><span>8 November 2019</span> <span id=\"ce5ba\"><span data-loading>Loading sharing buttons...</span><noscript>Please enable JavaScript to Share</noscript></span>\n    </p>\n  </div>\n  <div class=\"col-sm-3 col-lg-4\">\n    Topics:\n    <a class=\"d-block\" href=\"/topics/page speed optimisation\">page speed optimisation</a>\n    <a class=\"d-block\" href=\"/topics/web fonts\">web fonts</a>\n  </div>\n</div>\n\n<p>\n  In the previous part, I've show the theory behind asynchronous web font stylesheet loading and illustrated the process of page loading with experiments around performance measurements. Based on this data, I'll show my technique loading fonts in the most efficient manner. At the end, I'll show how to make embed a font on a web page so that it's immediately used when rendering the page, without a FOUT.\n</p>\n\n<h2 id=\"advanced-loading-lemuriafont\">Advanced Loading: @lemuria/font</h2>\n\n<p>\n  In part I, a number of times we've seen one drawback to preloading web fonts stylesheets dynamically even with the preload link: fonts won't begin to download immediately after the stylesheet is downloaded, but only only at the initial <strong>render stage</strong> <span style=\"background:rgb(166,144,232)\">Recalculate styles | Layout</span>, or after it if the stylesheet didn't have time to load before the first render. I've repeated the previous experiment multiple times, and I always see the same result, that the font download happens only at the purple render bar and never before it, even if the stylesheet is ready. Wouldn't it be nice to be able to start downloading fonts as soon as we have the fonts' urls? Plus, we're still to consolidate all reflows. The proposed solution is JavaScript-based:\n</p>\n\n<ul>\n  <li>Preload the stylesheet as <span class=\"tm\">fetch</span> resource.</li>\n  <li>Instead of adding the link with the stylesheet to DOM, download it using XHR.</li>\n  <li>Parse the stylesheet with JS to extract <span class=\"tm\">url()</span> links to fonts, add them do DOM as <span class=\"tm\">link</span> with <em>rel</em>=<strong>preload</strong> <em>as</em>=<strong>font</strong>. This will kick in downloading the fonts.</li>\n  <li>Wait for all fonts to load, then embed the stylesheet as inline style. This will result in a single reflow.</li>\n  <li>If the browser doesn't support preload, just fallback to standard font loading.</li>\n</ul>\n\n\n<p>\n  Let's get to code right away. Here's a simple script to fetch stylesheet, while measuring performance:\n</p>\n\n<div class=\"row\">\n  <div class=\"col order-2 order-md-1 d-flex justify-content-center\">\n    <pre id=\"ccdbf1\"><code class=\"javascript hljs\">/**\n * Download a resource with XHR.\n * @param {string} address The address to load.\n * @param {function(string)} cb The callback to call on complete.\n * @param {string} [marker] Performance annotation.\n */\nfunction fetchStylesheet(address, cb, marker = '') {\n  performance.mark('xhr-start'+marker)\n  const xhr = new XMLHttpRequest()\n  xhr.onreadystatechange = () =&gt; {\n    if(xhr.readyState == 4) {\n      if (xhr.status == 200) {\n        cb(xhr.responseText)\n        performance.mark('xhr-end'+marker)\n        performance.measure('xhr'+marker, 'xhr-start'+marker, 'xhr-end'+marker)\n      } else {\n        console.error('Error loading webfont: server responded with code %s at %s',\n          xhr.status, address)\n      }\n    }\n  }\n  xhr.open('GET', address)\n  try {\n    xhr.send(null)\n  } catch (err) {\n    console.error(err)\n  }\n}</code></pre>\n  </div>\n</div>\n<div class=\"row\">\n  <div class=\"col-md-4 order-2 order-md-1\">\n    <p>\n      The standard google fonts stylesheet contains a number of <span class=\"tm\">@font-face</span> records with CSS properties. The <span class=\"tm\">unicode-range</span> property allows to download fonts only if the page contains characters from that range, and it's annotated just above the record.\n      <br>\n      <img alt=\"latin font face animation\"\n        src=\"data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' width='150' height='170'/%3E\" data-io data-src=\"best-google-font-2/animate/fontface.gif\">\n      <noscript>\n        <img alt=\"latin font face animation\" src=\"best-google-font-2/animate/fontface.gif\">\n      </noscript>\n    </p>\n  </div>\n  <div class=\"col order-1 order-md-2 d-flex justify-content-center\">\n    <pre id=\"c1d47\"><code class=\"css hljs\">/* latin-ext */\n@font-face {\n  font-family: 'Gentium Basic';\n  font-style: italic;\n  font-weight: 400;\n  font-display: swap;\n  src:  local('GentiumBasic-Italic'), url(woff2) format('https://woff2');\n  unicode-range: U+0100-024F, U+0259, ...etc;\n}\n/* latin */\n@font-face {\n  font-family: 'Gentium Basic';\n  font-style: italic;\n  font-weight: 400;\n  font-display: swap;\n  src: local('GentiumBasic-Italic'), url(woff2) format('https://woff2');\n  unicode-range: U+0000-00FF, U+0131, ...etc;\n}</code></pre>\n  </div>\n</div>\n\n<div class=\"row\">\n  <div class=\"col order-2 order-md-1 d-flex justify-content-center\">\n    <pre id=\"ccdbf2\"><code class=\"javascript hljs\">function parseBody(result) {\n  const re = /url\\((.+?)\\).*?;\\s+unicode-range: (.+?);/g\n  let ranges = {}\n  const fonts = []\n  let a\n  while((a = re.exec(result))) {\n    const u = a[1]\n    const range = a[2]\n    fonts.push({ url: u, range })\n    ranges[range] = 1\n  }\n  ranges = Object.keys(ranges).reduce((acc, range) =&gt; {\n    const reg = range\n      .split(/,\\s/)\n      .map((r) =&gt; r.replace('U+', '\\\\u').replace('-', '-\\\\u'))\n      .join('').toLowerCase()\n    acc[range] = new RegExp(`[${reg}]`)\n    return acc\n  }, {})\n  // ...</code></pre>\n  </div>\n  <div class=\"col-md-4 order-1 order-md-2\">\n    <p>\n      Our stylesheet parsing function uses a regex to extract URLs with unicode ranges of fonts, and creates an array like <span class=\"tm\">[{ font: 'https://woff2', range: /[regex]/ }]</span> for each font it found in the stylesheet.\n      <br>\n      <br>\n      The <span class=\"tm\">U+0000-00FF,U+0131,...</span> range will become <span class=\"tm\">[\\u0000-\\u00FF\\\\u0131...]</span> JS regex.\n    </p>\n  </div>\n</div>\n\n<div class=\"row\" id=\"2-scenarios\">\n  <div class=\"col order-2 order-md-1 d-flex justify-content-center\">\n    <pre id=\"ccdbf3\"><code class=\"javascript hljs\">  // ..\n  const body = document.body ? document.body.textContent : ''\n  const validRanges = body ? Object.keys(ranges).reduce((acc, range) =&gt; {\n\n    // case A) body is loaded, test it against the regex.\n    const reg = ranges[range]\n    const valid = reg.test(body)\n    if (valid) acc[range] = true\n    return acc\n  }, {}) : Object.keys(ranges).reduce((acc, range) =&gt; {\n\n    // case B) body is not available, fallback to supplied ranges.\n    const valid = range in defaultRanges\n    if (valid) acc[range] = true\n    return acc\n  }, {})\n\n  // filter only fonts we need\n  urls = fonts.filter(({ range }) =&gt; {\n    return range in validRanges\n  }).map(({ url: u }) =&gt; u)\n\n  // if ranges are not supplied, and we're in case A, just add the stylesheet.\n  // we loose the advantage of eliminating continuous reflows due to fonts\n  // arriving independently at different times.\n  if (!urls.length) return loadedCb()\n\n  // preload fonts via link elements\n  // each appendChild has a cost, so bundle them into a fragment.\n  const fragment = document.createDocumentFragment()\n  urls.forEach((address, i) =&gt; {\n    const link = document.createElement('link')\n    link.href = address\n    link.rel = 'preload'\n    link.as = 'font'\n    const j = i + 1\n    performance.mark('link-preload-start'+j)\n    link.onload = () =&gt; loadedCb(j)\n    link.setAttribute('crossorigin', true)\n    fragment.appendChild(link)\n  })\n  document.head.appendChild(fragment)\n}</code></pre>\n  </div>\n  <div class=\"col-md-4 order-1 order-md-2\">\n    <p>\n      There are 2 scenarios when we'll get the stylesheet ready:\n      <br>\n      <br>\n       A) <em>after</em> HTML parsing, when <span class=\"tm\">body</span> is available. By running the regex against body's text content, we can figure out if we don't use <strong>latin-ext</strong> on the page, and just pass the unicode range for <strong>latin</strong> characters. This way, we don't have to download each single font in the stylesheet, wasting data; <em>and</em>\n      <br>\n      <br>\n       B) <em>prior</em> to HTML parsing, which can happen because there's another stylesheet blocking the render, and/or because the connection is very fast. Here, we wouldn't know the unicode ranges that are present on the page, therefore they have to be supplied as additional information. \n      <br>\n      <img alt=\"body not ready animation\"\n        src=\"data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' width='150' height='296'/%3E\" data-io data-src=\"best-google-font-2/animate/head2.gif\">\n      <noscript>\n        <img alt=\"body not ready animation\" src=\"best-google-font-2/animate/head2.gif\">\n      </noscript>\n    </p>\n  </div>\n</div>\n\n<div class=\"row\">\n  <div class=\"col-md-4 order-2 order-md-1\">\n    <p>\n      Finally I add some logic to keep track of parallel preloads and to embed the stylesheet when they all arrive and write the <span class=\"tm\">startPreload</span> function to wire all functions up together.\n    </p>\n  </div>\n  <div class=\"col order-1 order-md-2 d-flex justify-content-center\">\n    <pre id=\"ccdbf4\"><code class=\"javascript hljs\">let FONT_CSS\nlet urls = []\nlet loaded = 0\n\n/**\n * @param {number} [i] The index of the link\n */\nfunction loadedCb(i) {\n  if (i) {\n    performance.mark('link-preload-end'+i)\n    performance.measure('link-preload', 'link-preload-start'+i, 'link-preload-end'+i)\n  }\n  loaded++\n  if (loaded &gt;= urls.length) {\n    const style = document.createElement('style')\n    style.innerHTML = FONT_CSS\n    document.head.appendChild(style)\n\n    performance.mark('agf-end')\n    performance.measure('@lemuria/font', 'agf-start', 'agf-end')\n  }\n}\n\n// the entry main: fetch CSS and call parseBody,\n// which will call loadedCb for each font.\nfunction startPreload(linkEl, marker = 'link') {\n  const href = linkEl.href\n  fetchStylesheet(href, (res) =&gt; {\n    FONT_CSS = res\n    parseBody(FONT_CSS)\n  }, '-' + marker)\n}\n\n// kick in advanced google font preloading!\nstartPreload({ href: FONT }, 'js')</code></pre>\n  </div>\n</div>\n\n<p>\n  I could have used the <span class=\"tm\">fetch</span> instead of XHR since it's 2019, however I would need to add a polyfill and transpile async code. There's no performance difference between <span class=\"tm\">fetch</span> and <span class=\"tm\">XMLHttpRequest</span> APIs. One observation, is that with <span class=\"tm\">fetch</span>, data could be streamed, so if the response arrived in chunks, I could extract fonts as they come, but because the stylesheet is so small (&lt; 1kb), streaming is unnecessary. I've made a package called <a\n   title=\"Loads A Web Font Stylesheet (e.g., Google Fonts) Without Render Blocking And Multiple Layout Updates.\" class=\"NPMBadge\" href=\"https://npmjs.com/package/@lemuria/font\">\n   <span class=\"a\">@lemuria/font</span><span class=\"b\">1.0.4</span></a> with this code which I ran through <em>Google Closure Compiler</em>, so let's update our page:\n</p>\n\n<pre id=\"c6ce5\"><code class=\"xml hljs\">&lt;head&gt;\n  &lt;link rel=\"dns-prefetch\" href=\"//fonts.googleapis.com\"&gt;\n  &lt;link rel=\"preconnect\" href=\"https://fonts.gstatic.com\" crossorigin&gt;\n  &lt;link rel=\"preload\" href=\"https://fonts.googleapis.com/css?display=swap&amp;family=Gentium+Basic:400,400i,700|Limelight\" as=\"fetch\"&gt;\n  &lt;script&gt;\n    (function(){window[\"@lemuria/font\"]=function(q,k){function x(a){for(var f=/url\\((.+?)\\).*?;\\s+unicode-range: (.+?);/g,b={},d=[],h;h=f.exec(a);){var r=h[2];d.push({url:h[1],a:r});b[r]=1}b=Object.keys(b).reduce(function(c,e){var g=e.split(/,\\s/).map(function(l){return l.replace(\"U+\",\"\\\\u\").replace(\"-\",\"-\\\\u\")}).join(\"\").toLowerCase();c[e]=new RegExp(\"[\"+g+\"]\");return c},{});var t=document.body?document.body.textContent:\"\",y=t?Object.keys(b).reduce(function(c,e){b[e].test(t)&amp;&amp;(c[e]=!0);return c},{}):Object.keys(b).reduce(function(c,\n    e){e in k&amp;&amp;(c[e]=!0);return c},{});m=d.filter(function(c){return c.a in y}).map(function(c){return c.url});if(!m.length)return u();var v=document.createDocumentFragment();m.forEach(function(c,e){var g=document.createElement(\"link\");g.href=c;g.rel=\"preload\";g.as=\"font\";var l=e+1;performance.mark(\"link-preload-start\"+l);g.onload=function(){return u(l)};g.setAttribute(\"crossorigin\",!0);v.appendChild(g)});document.head.appendChild(v)}k=void 0===k?{}:k;var n=document.createElement(\"link\");if(function(a,\n    f){if(!a||!a.supports)return!1;try{return a.supports(f)}catch(b){return!1}}(n.relList,\"preload\")){var z=function(a,f,b){b=void 0===b?\"\":b;performance.mark(\"xhr-start\"+b);var d=new XMLHttpRequest;d.onreadystatechange=function(){4==d.readyState&amp;&amp;(200==d.status?(f(d.responseText),performance.mark(\"xhr-end\"+b),performance.measure(\"xhr\"+b,\"xhr-start\"+b,\"xhr-end\"+b)):console.error(\"Error loading webfont: server responded with code %s at %s\",d.status,a))};d.open(\"GET\",a);try{d.send(null)}catch(h){console.error(h)}};\n    performance.mark(\"agf-start\");var p;(function(a,f){z(a.href,function(b){p=b;x(p)},\"-\"+(void 0===f?\"link\":f))})({href:q},\"js\");var m=[],w=0,u=function(a){a&amp;&amp;(performance.mark(\"link-preload-end\"+a),performance.measure(\"link-preload\",\"link-preload-start\"+a,\"link-preload-end\"+a));w++;w&gt;=m.length&amp;&amp;(a=document.createElement(\"style\"),a.innerHTML=p,document.head.appendChild(a),performance.mark(\"agf-end\"),performance.measure(\"@lemuria/font\",\"agf-start\",\"agf-end\"))}}else n.rel=\"stylesheet\",n.href=q,document.head.appendChild(n)};}).call(this);\n\n    window['@lemuria/font']\n      ('https://fonts.googleapis.com/css?display=swap&amp;family=Gentium+Basic:400,400i,700|Limelight')\n  &lt;/script&gt;\n&lt;/head&gt;</code></pre>\n\n<p>\n  I've left plenty of performance markers, but there's a version that doesn't have them. What does the resulting timeline look like? Have we solved the problem of throttling fonts' reflows?\n</p>\n\n</div></div></div>\n<div class=\"container-fluid\">\n  <div class=\"row\">\n    <div id=\"advanced-loading\" style=\"overflow: hidden;\"\n      class=\"lg-6 col d-flex align-items-center justify-content-center flex-column mb-3 p-3 rounded position-relative\">\n      <div class=\" Parallax\" data-loading style=\"z-index: -1;\" id=\"c709f\"></div>\n      <div style=\"z-index: -1;\" class=\"Parallax\"></div>\n      <noscript>\n        <div class=\" Parallax\" style=\"background-image: url(/img/letters/background.png); z-index: -1;\"></div>\n      </noscript>\n      <p class=\"text-center\">\n        <img alt=\"Advanced asynchronous Google Font performance: achieving single reflow.\"\n          src=\"data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' width='761' height='659'/%3E\" data-io class=\"border rounded img-fluid\"\n          data-src=\"best-google-font-2/graphics/dev8.png\">\n        <noscript>\n          <img alt=\"Advanced asynchronous Google Font performance: achieving single reflow.\"\n            class=\"border rounded img-fluid\" src=\"best-google-font-2/graphics/dev8.png\">\n        </noscript>\n      </p>\n      <h5 id=\"figure-1-advanced-asynchronous-google-font-performance-achieving-single-reflow\"\n        class=\"m-0 d-inline-block\" style=\"background: white;\">\n        Figure 1: Advanced asynchronous Google Font performance: achieving single reflow.\n      </h5>\n    </div>\n  </div>\n</div>\n<div class=\"container\"><div class=\"row\"><div class=\"col\">\n\n<div class=\"mb-3 Revision Blue\">\n  <ol style=\"background-image: url('../articles/img/sketch.svg');\">\n    <li>As soon as the page starts parsing, we begin the XHR request, but the XHR resource has already started downloading. The script evaluation takes <em>10ms</em>.</li>\n    <li>The download completes (purple line), but the thread is blocked. The XHR waits until it's freed to call the callback. Fonts don't begin to download but we can't do anything about it. Once the thread is available, we inject 4 links and assign an <span class=\"tm\">onload</span> listener to each them.</li>\n    <li>When all <span class=\"tm\">onload</span> events have fired, we add the stylesheet to DOM as a style. Despite the fact that fonts arrived at different times, we only see one reflow which takes 100ms. The page's <span class=\"tm\">onload</span> event is thus delivered quicker and the users and Google are happy.</li>\n  </ol>\n  <div class=\"position-absolute\"\n    style=\"width: 1rem; bottom: 0px; top: 0px; right: 1rem; border-left: 1px solid #ec6a9d;\">\n    <img src=\"/img/arrows.svg\">\n  </div>\n</div>\n\n<p>\n  Bingo bongo (<em>sic</em>, <em>lame</em>), we've achieved the maximum optimisation of a Google Font. Let's just see what if there's a render blocking resource, such as an external CSS that would give us some additional time to fetch the web font stylesheet:\n</p>\n\n</div></div></div>\n<div class=\"container-fluid\">\n  <div class=\"row\">\n    <div style=\"overflow: hidden;\"\n      class=\"lg-6 col d-flex align-items-center justify-content-center flex-column mb-3 p-3 rounded position-relative\">\n      <div class=\" Parallax\" data-loading style=\"z-index: -1;\" id=\"c709f1\"></div>\n      <div style=\"z-index: -1;\" class=\"Parallax\"></div>\n      <noscript>\n        <div class=\" Parallax\" style=\"background-image: url(/img/letters/background.png); z-index: -1;\"></div>\n      </noscript>\n      <p class=\"text-center\">\n        <img alt=\"@Lemuria/font parsing starting before body is available without default unicode-ranges.\"\n          src=\"data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' width='761' height='659'/%3E\" data-io class=\"border rounded img-fluid\"\n          data-src=\"best-google-font-2/graphics/dev9.png\">\n        <noscript>\n          <img alt=\"@Lemuria/font parsing starting before body is available without default unicode-ranges.\"\n            class=\"border rounded img-fluid\" src=\"best-google-font-2/graphics/dev9.png\">\n        </noscript>\n      </p>\n      <h5\n        id=\"figure-2-lemuriafont-parsing-starting-before-body-is-available-without-default-unicode-ranges\" class=\"m-0 d-inline-block\" style=\"background: white;\">\n        Figure 2: @Lemuria/font parsing starting before body is available without default unicode-ranges.\n      </h5>\n    </div>\n  </div>\n</div>\n<div class=\"container\"><div class=\"row\"><div class=\"col\">\n\n<div style=\"transform: rotate3d(1,1,1,2deg);\" class=\"mb-3 Revision Blue\">\n  <ol style=\"background-image: url('../articles/img/sketch.svg');\">\n    <li>The advanced font loading script is executed, and taps into the preload download, but by the time the XHR is finished, the script cannot find <span class=\"tm\">body</span> and there are no default unicode ranges. It falls back to essentially just appending a link tag with the style to the head.</li>\n    <li>The additional external stylesheet for our page begins to parse only now.</li>\n    <li>Fonts arrive one by one in 3 different waves.</li>\n  </ol>\n  <div class=\"position-absolute\"\n    style=\"width: 1rem; bottom: 0px; top: 0px; right: 1rem; border-left: 1px solid #ec6a9d;\">\n    <img src=\"/img/arrows.svg\">\n  </div>\n</div>\n\n<p>\n  In this experiment, instead of inlining the page style, I added a link to it, so that the browser has to download it. Although such download happens really quickly, the page nevertheless is slowed down by much more than just the download time. Unlike in the previous case, now when the <span class=\"tm\">@lemuria/font</span> function is executed, the body is still not available because the parsing has not started. This just shows that it's not just the download speed that increases the start up time for external stylesheets, but their loading time also <em>total: 84.12 ms (15.12 ms network transfer + 69.01 ms resource loading)</em>. Again, this is my 2008 MacBook but the idea is that when executing a script in the head, the body might not be available, even if an external resource has downloaded, because browsers take responsibility to spin off such downloads as soon as they can, because it's <strong>critical</strong> resource paths.\n</p>\n\n<p class=\"SectionBreak\">\n  <a title=\"Back To Top\" href=\"#top\">\n    <img alt=\"section break\"\n      src=\"data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' width='40' height='15'/%3E\" data-io data-src=\"/section-breaks/0.svg\">\n    <noscript><img alt=\"section break\" src=\"/section-breaks/0.svg\"></noscript></a>\n</p>\n\n\n\n\n<h3 id=\"non-blocking\" class=\"d-md-none\">Non-Blocking Proof</h3>\n\n</div></div></div>\n<div class=\"container\">\n  <div class=\"row\">\n    <div style=\"overflow: hidden;\"\n      class=\"lg-6 col d-flex align-items-center justify-content-center flex-column mb-3 p-3 rounded position-relative\">\n      <div class=\" Parallax\" data-loading style=\"z-index: -1;\" id=\"c709f2\"></div>\n      <div style=\"z-index: -1;\" class=\"Parallax\"></div>\n      <noscript>\n        <div class=\" Parallax\" style=\"background-image: url(/img/letters/background.png); z-index: -1;\"></div>\n      </noscript>\n      <p class=\"text-center\">\n        <img alt=\"Dynamic insertion of a link with JS does not block page render.\"\n          src=\"data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' width='639' height='486'/%3E\" data-io class=\"border rounded img-fluid\"\n          data-src=\"best-google-font-2/graphics/dev-check.gif\">\n        <noscript>\n          <img alt=\"Dynamic insertion of a link with JS does not block page render.\"\n            class=\"border rounded img-fluid\" src=\"best-google-font-2/graphics/dev-check.gif\">\n        </noscript>\n      </p>\n      <h5 id=\"figure-3-dynamic-insertion-of-a-link-with-js-does-not-block-page-render\"\n        class=\"m-0 d-inline-block\" style=\"background: white;\">\n        Figure 3: Dynamic insertion of a link with JS does not block page render.\n      </h5>\n    </div>\n    <div class=\"col-lg-6 d-flex align-items-center justify-content-center flex-column\">\n      <h3 id=\"non-blocking-proof\" class=\"d-none d-md-block\">Non-Blocking Proof</h3>\n        <p>\n          For a scary moment though, I thought that I might be giving wrong advice when saying to append a <span class=\"tm\">link</span> tag dynamically into the head, and it will actually block the page from rendering. For example, on the previous Fig 1, there are some gaps in the timeline after the web font stylesheet is inserted, but before the external CSS is parsed, that could indicate that the page was render-blocked.\n        </p>\n        <p>\n          However, it's not the case as shown <span id=\"Above\">above</span><span id=\"OnLeft\">on the left</span>, and the reason for these gaps is that the browser has to pause to parse the external style, allowing some async JS to report to the main thread via callbacks (e.g., here, XHR is completed quicker compared to the <a href=\"#fig-advanced-loading\">previous case</a>, where it had to wait for the main thread to unlock since there were no gaps).\n        </p>\n    </div>\n  </div>\n</div>\n<div class=\"container\"><div class=\"row\"><div class=\"col\">\n\n<p>\n  Essentially all I've done is added an external stylesheet dynamically, but throttled it server-side with a middleware function. Because the page continued to render, it's safe to say that adding a link with JS in the head will not block the main thread.\n</p>\n\n<div class=\"row\">\n  <div class=\"col-md-6\">\n    <pre id=\"c6ce52\"><code class=\"xml hljs\">&lt;head&gt;\n&lt;link rel=\"preload\" href=\"/throttle.css\" as=\"style\"&gt;\n  &lt;script&gt;\n    const link = document.createElement('link')\n    link.href = '/throttle.css'\n    link.rel = 'stylesheet'\n    performance.mark('add-stylesheet')\n    document.head.appendChild(link)\n    link.onload = () =&gt; {\n      performance.measure('stylesheet-onload', 'add-stylesheet');\n    }\n  &lt;/script&gt;\n&lt;/head&gt;</code></pre>\n  </div>\n  <div class=\"col-md-6\">\n    <pre id=\"ccdbf\"><code class=\"javascript hljs\">// Koa middleware\nasync throttle(ctx, next) {\n  if (ctx.path == '/throttle.css') {\n    await new Promise(r =&gt; setTimeout(r, 500))\n    ctx.type = 'text/css'\n    ctx.body = ''\n  }\n  await next()\n}</code></pre>\n  </div>\n</div>\n\n<p class=\"SectionBreak\">\n  <a title=\"Back To Top\" href=\"#top\">\n    <img alt=\"section break\"\n      src=\"data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' width='40' height='13'/%3E\" data-io data-src=\"/section-breaks/1.svg\">\n    <noscript><img alt=\"section break\" src=\"/section-breaks/1.svg\"></noscript></a>\n</p>\n\n\n<h3 id=\"unicode-range-application\">Unicode Range Application</h3>\n\n<p>\n  So finally, let me show a case with an external stylesheet, and with unicode-range. The unicode-range can be looked up in the Google's servers response, but I'm quite sure they are pretty static so you wouldn't have to do it often (but keep an eye out for them).\n</p>\n\n<pre id=\"c6ce51\"><code class=\"xml hljs\">&lt;head&gt;\n  &lt;link rel=\"preload\" crossorigin href=\"https://fonts.googleapis.com/css?display=swap&amp;family=Gentium+Basic:400,400i,700|Limelight\" as=\"fetch\"&gt;\n  &lt;script&gt;\n    // @lemuria/font source\n    var range = 'U+0000-00FF, U+0131, U+0152-0153, U+02BB-02BC, U+02C6, U+02DA, U+02DC, U+2000-206F, ' +\n                'U+2074, U+20AC, U+2122, U+2191, U+2193, U+2212, U+2215, U+FEFF, U+FFFD'\n    window['@lemuria/font']\n      ('https://fonts.googleapis.com/css?display=swap&amp;family=Gentium+Basic:400,400i,700|Limelight', {\n        [range]: true, // latin range\n      })\n  &lt;/script&gt;\n&lt;/head&gt;</code></pre>\n\n</div></div></div>\n<div class=\"container-fluid\">\n  <div class=\"row\">\n    <div style=\"overflow: hidden;\"\n      class=\"lg-6 col d-flex align-items-center justify-content-center flex-column mb-3 p-3 rounded position-relative\">\n      <div class=\" Parallax\" data-loading style=\"z-index: -1;\" id=\"c709f3\"></div>\n      <div style=\"z-index: -1;\" class=\"Parallax\"></div>\n      <noscript>\n        <div class=\" Parallax\" style=\"background-image: url(/img/letters/background.png); z-index: -1;\"></div>\n      </noscript>\n      <p class=\"text-center\">\n        <img\n          alt=\"@Lemuria/font with unicode-range info allows to download fonts in parallel to the main thread.\" src=\"data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' width='817' height='597'/%3E\"\n          data-io class=\"border rounded img-fluid\" data-src=\"best-google-font-2/graphics/dev10.png\">\n        <noscript>\n          <img\n            alt=\"@Lemuria/font with unicode-range info allows to download fonts in parallel to the main thread.\" class=\"border rounded img-fluid\" src=\"best-google-font-2/graphics/dev10.png\">\n        </noscript>\n      </p>\n      <h5\n        id=\"figure-4-lemuriafont-with-unicode-range-info-allows-to-download-fonts-in-parallel-to-the-main-thread\" class=\"m-0 d-inline-block\" style=\"background: white;\">\n        Figure 4: @Lemuria/font with unicode-range info allows to download fonts in parallel to the main thread.\n      </h5>\n    </div>\n  </div>\n</div>\n<div class=\"container\"><div class=\"row\"><div class=\"col\">\n\n<div class=\"mb-3 Revision Blue\">\n  <ol style=\"background-image: url('../articles/img/sketch.svg');\">\n    <li>The font script begins the XHR request as soon as HTML starts to parse. It might look like the thread is blocked because the browser is not doing anything during the XHR, however it's not so otherwise there would be a long solid orange line saying \"Evaluating JS\", but there's just a gap. The browser is doing something, but there's no info to it. The XHR is async so it's not blocking the thread.<br><br></li>\n    <li>The XHR is finished but the body is not present. Because we've passed the desired <span class=\"tm\">unicode-range</span>, the script inserts the font preload links, and they begin to download. This allows to parallelise their download with the initial render.<br><br></li>\n    <li>Once the thread is freed (the <span style=\"background:blue; color:white\" class=\"px-2\"><abbr title=\"Dom Content Loaded\">DCL</abbr></span> event), there's a bit of work to do for other JS scripts on the page, after which the web font stylesheet is applied. Notice there's only <em>150ms</em> delay between the <span style=\"background:green; color:white\" class=\"px-2\"><abbr title=\"First Paint\">FP</abbr></span> and fonts being added which gives us the fastest FOUT so far.</li>\n  </ol>\n  <div class=\"position-absolute\"\n    style=\"width: 1rem; bottom: 0px; top: 0px; right: 1rem; border-left: 1px solid #ec6a9d;\">\n    <img src=\"/img/arrows.svg\">\n  </div>\n</div>\n\n<p>\n  Cool, I think we've optimised as much as possible out of <em>Google Fonts</em>. The final version enables to insert the stylesheet before the initial layout, and also downloads fonts in parallel to the main thread which is busy rendering. Practically, this is only possible if the device is pretty slow and/or there are render blocking resources that will postpone the parsing for some time long enough for the web font stylesheet preload to complete.\n  <!-- In case there are none, I've tried the following trick: -->\n</p>\n\n<!-- <span class=\"tm\">`</span>html -->\n<!-- <head> -->\n  <!-- ... -->\n  <!-- <link href=\"data:text/css;charset=utf-8,\" rel=\"stylesheet\"> -->\n<!-- </head> -->\n<!-- <span class=\"tm\">`</span> -->\n\n<!-- <p>\n  In words, I added a data-url link in hope that the browser will pause to download it which will give the XHR callback a chance to fire (it <a href=\"#fig-advanced-loading\" onclick=\"document.querySelector(this.getAttribute('href')).scrollIntoView({behavior: 'smooth'}); return false\">does not fire</a> if there are no external resources), however that didn't work ü§∑‚Äç‚ôÄÔ∏è. Let me wrap up to conclusions.\n</p> -->\n\n<p class=\"SectionBreak\">\n  <a title=\"Back To Top\" href=\"#top\">\n    <img alt=\"section break\"\n      src=\"data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' width='40' height='13'/%3E\" data-io data-src=\"/section-breaks/2.svg\">\n    <noscript><img alt=\"section break\" src=\"/section-breaks/2.svg\"></noscript></a>\n</p>\n\n<h2 id=\"comparison\">Comparison</h2>\n\n<p>\n  Google Fonts are great because it's really easy to embed them and the service provides a variety of good-looking web fonts. The standard sync loading with a simple link tag, however, will lock the main thread and not prevent the page (even HTML won't start parsing) which we would like to avoid. Moreover, fonts will load independently, and each time they will cause a reflow of the page, which slows down the <span class=\"px-2\" style=\"background:red; color:white\"><abbr title=\"Load\">L</abbr></span> event delivery and frustrates the user. In summary, we've gone through the following stages for optimisation from the sync loading:\n</p>\n\n<h4 id=\"1-async-loading\" class=\"text-center\">1) Async Loading</h4>\n<hr>\n\n<div class=\"position-relative float-md-right pl-3 pb-3\" id=\"c5f46\">\n  <img alt=\"async google font animation\"\n    src=\"data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' width='505' height='299'/%3E\" data-io class=\"img-fluid\"\n    data-src=\"best-google-font-2/graphics/async-google-font.png\">\n  <noscript>\n    <img alt=\"async google font animation\" class=\"img-fluid\"\n      src=\"best-google-font-2/graphics/async-google-font.png\">\n  </noscript>\n</div>\n\n<p>\n  Instead of adding a link tag in the markup, we add a simple script to create the link dynamically. This technique allows to transform sync render-blocking loading of resources into async non-blocking loading, and eliminates the Lighthouse warning. We also add a preload link so that the resource begins to download immediately rather than waiting for the script to execute.\n</p>\n<p>\n  We've also looked at another method when instead of a script tag, the <span class=\"tm\">onload</span> attribute on the preload link is used to upgrade the <em>rel</em> from <strong>preload</strong> to <strong>stylesheet</strong>, however as I've shown, this has a disadvantage that if the stylesheet arrives after the initial render, it will cause an expensive reflow, despite the fact that fonts are not even loaded. Therefore I suggest it's better to use the traditional script element right under the preload link.\n</p>\n\n<h4 id=\"2-advanced-loading\" class=\"text-center\">2) Advanced Loading</h4>\n\n<hr>\n\n<p>\n  Although async loading better than sync one, it's still not perfect, because we still have multiple reflows due to independent font loading. I propose a solution where an Ajax request is made to fetch the stylesheet, extract urls to fonts, preload them, and once they are all ready, embed the stylesheet into DOM.\n</p>\n\n<div class=\"position-relative float-md-left pr-3 pb-3\" id=\"c228f\">\n  <img alt=\"advanced google font animation\"\n    src=\"data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' width='505' height='299'/%3E\" data-io class=\"img-fluid\"\n    data-src=\"best-google-font-2/graphics/advanced-google-font.png\">\n  <noscript>\n    <img alt=\"advanced google font animation\" class=\"img-fluid\"\n      src=\"best-google-font-2/graphics/advanced-google-font.png\">\n  </noscript>\n</div>\n\n<p>\n  Any external CSS will postpone the parsing of HTML until it's received, but not only for the length of its download time, but for the duration of its loading time, which might be much longer than the download one. <span style=\"background:green; color: white\">Therefore when we're talking about maximum optimisation, such as for a landing page of a product, we might want to embed the full stylesheet onto the page so that we don't have to wait for it.</span> The browser treats this case differently and the loading pattern is continuous, i.e., start of parsing leads to layout without any gaps. However, if we have a web portal with multiple pages that share same styles, like a forum, it might not be feasible to embed CSS onto each page. Here, we're not that concerned with making an impression on the user with lightning-fast pages, but just want to deliver content. These are 2 broad cases that each deserving its own treatment.\n</p>\n<p>\n  When there are no external CSS, our script will begin to download XHR, but will probably have to wait until the initial rendering is done to parse it and begin to download fonts. When there are external CSS that blocked the page, the script might get a chance to parse the stylesheet, but it won't have information about the <span class=\"tm\">body</span>'s content to correctly apply <span class=\"tm\">unicode-range</span>, therefore we can supply that info manually to prevent unused fonts from extended ranges from downloading. In the latter case, we will be able to download fonts in parallel to the main thread doing the layout job, and apply the style right after the thread is freed, that is after the <span style=\"background:blue; color:white\" class=\"px-2\"><abbr title=\"Dom Content Loaded\">DCL</abbr></span> event. This scenario is when the loading is the fastest.\n</p>\n\n<p>\n  There might be some disadvantages to the method:\n</p>\n\n<ol>\n  <li>The script might take up some time to evaluate and if it can create preload links before parsing of HTML, it will also take additional time to insert them into DOM (takes 5-20ms) on my computer. We might have saved some time because all fonts were injected at once, but that time was after first paint, whereas now we might blocking the browser for about 30-40ms before the first paint (not so bad if XHR finishes after the initial render).</li>\n  <li>If there is a really large number of fonts, we will have to wait for each one of them to download, which might not be desirable. However in that case, we can break up the fonts into multiple batches by calling the <span class=\"tm\">@lemuria/font</span> function multiple times.</li>\n</ol>\n\n<p>\n  On the other hand, the <span class=\"tm\">@lemuria/font</span> script works as a polyfill for <span class=\"tm\">display:swap</span> which is not available for Edge. However, because it embeds fonts with <em>preload</em> links, it will not work on the IE/Edge12-16/Firefox. I thought about downloading fonts with XHR to prime the network cache, however after I downloaded them this way, and then injected the web font stylesheet referencing them, they were re-downloaded. A solution to this would be to embed fonts into the webpage with <span class=\"tm\">data:application/font</span> url, however that would trigger <span class=\"tm\">data:</span> string parsing and slow down the page.\n</p>\n\n<p>\n  <a\n    title=\"Loads A Web Font Stylesheet (e.g., Google Fonts) Without Render Blocking And Multiple Layout Updates.\" class=\"NPMBadge\" href=\"https://npmjs.com/package/@lemuria/font\">\n    <span class=\"a\">@Lemuria/font</span><span class=\"b\">1.0.4</span></a> package is available from NPM, and exports functions that could be added to a server-side rendered webpage. The source code of the function for manual injection can be copied from <a href=\"https://github.com/kumarikandam/font\">Github</a>. The check for <span class=\"tm\">preload</span> support is done the following way, <a target=\"_blank\" rel=\"noopener\" style=\"color: #e33a2c !important; text-decoration: underline;\"\n   href=\"https://www.smashingmagazine.com/2016/02/preload-what-is-it-good-for/\">\n   <nobr><img style=\"max-height:1em; margin-right:-0.2em;vertical-align: top;\n       margin-top: .2em;\"\n  alt=\"S\" data-io data-src=\"best-google-font-2/graphics/smashing.png\">\n<noscript>\n  <img style=\"max-height:1em; margin-right:-0.2em;vertical-align: top;\n         margin-top: .2em;\"\n    alt=\"S\" src=\"best-google-font-2/graphics/smashing.png\">\n</noscript>uggested by preload</nobr></a> contributor to Chrome:\n</p>\n\n<div class=\"row\">\n  <div class=\"col order-2 order-md-1 d-flex justify-content-center\">\n    <pre id=\"ccdbf5\"><code class=\"javascript hljs\">function DOMTokenListSupports(tokenList, token) {\n  if (!tokenList || !tokenList.supports) {\n    return false\n  } try { return tokenList.supports(token) } catch (e) {\n    return false }\n}\nconst link = document.createElement('link')\nconst linkSupportsPreload = DOMTokenListSupports(link.relList, 'preload')</code></pre>\n  </div>\n</div>\n\n\n<p>\n  Finally, the best possible course of action is to preload fonts with a preload link without any scripting. However, that's a different context entirely since this article focuses specifically on <em>Google Fonts</em> optimisation. Their servers will return different urls for different browsers, therefore we can't just copy and paste them in the preload link, additionally their fonts evolve and change versions. The advanced google font loading solution is the simplest scripting solution to kicking off font preload as soon as possible, and eliminate render blocks.\n</p>\n<p>\n  Moreover, I was asking myself, does the browser know internally the unicode range of the page even before body is available to JS? The last experiment was to embed the stylesheet manually with a <span class=\"tm\">&lt;style&gt;/* contents of google font stylesheet */&lt;/style&gt;</span> onto the page and see its performance. There are no external resources and the page load should proceed seamlessly from parsing to layout.\n</p>\n\n<pre id=\"c1602\"><code class=\"xml hljs\">&lt;head&gt;\n  &lt;link rel=\"dns-prefetch\" href=\"//fonts.googleapis.com\"&gt;\n  &lt;link rel=\"preconnect\" href=\"https://fonts.gstatic.com\" crossorigin&gt;\n\n  &lt;style&gt;\n    /* latin-ext */\n    @font-face {\n      font-family: 'Gentium Basic';\n      font-style: italic;\n      font-weight: 400;\n      font-display: swap;\n      src: local('Gentium Basic Italic'), local('GentiumBasic-Italic'), url(https://fonts.gstatic.com/s/gentiumbasic/v11/WnzjHAw9aB_JD2VGQVR80We3LAi5hBo7QoCBZCxP.woff2) format('woff2');\n      unicode-range: U+0100-024F, U+0259, U+1E00-1EFF, U+2020, U+20A0-20AB, U+20AD-20CF, U+2113, U+2C60-2C7F, U+A720-A7FF;\n    }\n    /* etc */\n&lt;/style&gt;</code></pre>\n\n</div></div></div>\n<div class=\"container-fluid\">\n  <div class=\"row\">\n    <div style=\"overflow: hidden;\"\n      class=\"lg-6 col d-flex align-items-center justify-content-center flex-column mb-3 p-3 rounded position-relative\">\n      <div class=\" Parallax\" data-loading style=\"z-index: -1;\" id=\"c709f4\"></div>\n      <div style=\"z-index: -1;\" class=\"Parallax\"></div>\n      <noscript>\n        <div class=\" Parallax\" style=\"background-image: url(/img/letters/background.png); z-index: -1;\"></div>\n      </noscript>\n      <p class=\"text-center\">\n        <img alt=\"Embedding contents of a web fonts styles manually.\"\n          src=\"data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' width='671' height='522'/%3E\" data-io class=\"border rounded img-fluid\"\n          data-src=\"best-google-font-2/graphics/dev11.gif\">\n        <noscript>\n          <img alt=\"Embedding contents of a web fonts styles manually.\" class=\"border rounded img-fluid\"\n            src=\"best-google-font-2/graphics/dev11.gif\">\n        </noscript>\n      </p>\n      <h5 id=\"figure-5-embedding-contents-of-a-web-fonts-styles-manually\" class=\"m-0 d-inline-block\"\n        style=\"background: white;\">\n        Figure 5: Embedding contents of a web fonts styles manually.\n      </h5>\n    </div>\n  </div>\n</div>\n<div class=\"container\"><div class=\"row\"><div class=\"col\">\n\n<p>\n  The performance graph clearly shows that although urls to fonts are there on the page, they don't begin to download prior to the first style calculation. Therefore, the advanced google font method is even better that what browser can offer natively, because it's able to begin to download fonts even before parsing starts by extracting urls from the stylesheet, if it arrives quickly enough (<a href=\"#2-scenarios\">case B</a>).\n</p>\n\n<p>\n  <span id=\"c704d\"><span data-loading>Loading sharing buttons...</span><noscript>Please enable JavaScript to Share</noscript></span>\n</p></div>\n  </div>\n</div>\n",
  "file": "./best-google-font-2",
  "postAjax": "(function imgPostAjax() {\n  /* eslint-env browser */\n  window['IO']()\n  window['WEBP']()\n})()"
}