{
  "title": "The Best Way To Load Google Fonts Asynchronously",
  "content": "<div class=\"container\">\n  <div class=\"row\">\n    <div col>\n      \n\n<h1 id=\"the-best-way-to-load-google-fonts-asynchronously\">The Best Way To Load Google Fonts Asynchronously</h1>\n\n<p class=\"H1Lead lead\"> &gt; Part II of <em>Advanced Google Font</em>. Go to Part I: <a href=\"how-to-load-google-fonts-asynchronously.html\">How To Load Google Fonts Asynchronously</a> and Part III: <a href=\"embedding-critical-path-fonts.html\">Embedding Critical Path Fonts</a>.</p>\n\n<div class=\"row mb-3\">\n  <div class=\"col-2 col-sm-2 col-lg-1\">\n    <img class=\"rounded img-fluid\" alt=\"anton photo\" src=\"data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' width='100' height='100'/%3E\" data-io>\n    <noscript><img class=\"rounded img-fluid\" alt=\"anton photo\" src=\"avatar/anton3.jpg\"></noscript>\n  </div>\n  <div class=\"col-10 col-sm-7\" style=\"border-bottom: 1px solid grey;\">\n    <p class=\"text-right\" style=\"color: grey;\">\n      <span>Anton Dmukhovskiy, Senior Software Developer</span><br>\n      <span>8 November 2019</span>  \n      <span class=\"SplendidSharingButtons\"><span id=\"ce5ba\"><span class=\"d-inline-block\" style=\"height:24px\" data-loading>Loading sharing buttons...</span><noscript>Please enable JavaScript to Share</noscript></span></span>\n    </p>\n  </div>\n  <div class=\"col-sm-3 col-lg-4\">\n    <img class=\"d-block\" alt=\"views counter\" src=\"https://api.artd.eco/counter.svg\">Topics: <a href=\"topics.html#page-speed-optimisation\">page speed optimisation</a>, <a href=\"topics.html#web-fonts\">web fonts</a>\n  </div>\n</div>\n\n<p>In the previous part, I've show the theory behind asynchronous web font stylesheet loading and illustrated the process of page loading with experiments around performance measurements. Based on this data, I'll show my technique loading fonts in the most efficient manner. At the end, I'll show how to make embed a font on a web page so that it's immediately used when rendering the page, without a FOUT.</p>\n\n<h2 id=\"advanced-loading-lemuriafont\">Advanced Loading: @lemuria/font</h2>\n\n<p>In part I, a number of times we've seen one drawback to preloading web fonts stylesheets dynamically even with the preload link: fonts won't begin to download immediately after the stylesheet is downloaded, but only only at the initial <strong>render stage</strong> <span style=\"background:rgb(166,144,232)\">Recalculate styles | Layout</span>, or after it if the stylesheet didn't have time to load before the first render. I've repeated the previous experiment multiple times, and I always see the same result, that the font download happens only at the purple render bar and never before it, even if the stylesheet is ready. Wouldn't it be nice to be able to start downloading fonts as soon as we have the fonts' urls? Plus, we're still to consolidate all reflows. The proposed solution is JavaScript-based:</p>\n\n<ul>\n  <li>Preload the stylesheet as a <span class=\"tm\">fetch</span> resource.</li>\n  <li>Instead of adding the link with the stylesheet to DOM, download it using XHR.</li>\n  <li>Parse the stylesheet with JS to extract <span class=\"tm\">url()</span> links to fonts, add them do DOM as <span class=\"tm\">link</span> with <em>rel</em>=<strong>preload</strong> <em>as</em>=<strong>font</strong>. This will kick in downloading the fonts.</li>\n  <li>Wait for all fonts to load, then embed the stylesheet as inline style. This will result in a single reflow.</li>\n  <li>If the browser doesn't support preload, just fallback to standard font loading.</li>\n</ul>\n\n\n<p>Let's get to code right away. Here's a simple script to fetch stylesheet, while measuring performance:</p>\n\n<div class=\"row\">\n  <div class=\"order-1 order-md-2 d-flex align-items-center justify-content-between flex-column col-md-4\">\n    <div>\n      <p>\n        The main idea behind the <em>Advanced Google Font</em> strategy is to handle loading of fonts programmatically. By taking control over assets loading process, we'll be able to inject all fonts at once in a so-called <em>fonts flush</em>, thus reducing the number of reflows to just one.\n      </p>\n      <p>To find out the URLs of fonts, we fetch the stylesheet with a simple XHR request.</p>\n    </div>\n    <img class=\"img-fluid\" alt=\"css fetch by lasso animation\" src=\"data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' width='270' height='240'/%3E\" data-io>\n    <noscript>\n      <img class=\"img-fluid\" alt=\"css fetch by lasso animation\" src=\"best-google-font-2/animate/css.gif\">\n    </noscript>\n  </div>\n  <div class=\"order-2 order-md-1 d-flex justify-content-center align-items-center col\">\n    <pre id=\"ccdbf5\"><code class=\"javascript hljs\">/**\n * Download a resource with XHR.\n * @param {string} address The address to load.\n * @param {function(string)} cb The callback to call on complete.\n * @param {string} [marker] Performance annotation.\n */\nfunction fetchStylesheet(address, cb, marker = '') {\n  performance.mark('xhr-start'+marker)\n  const xhr = new XMLHttpRequest()\n  xhr.onreadystatechange = () =&gt; {\n    if(xhr.readyState == 4) {\n      if (xhr.status == 200) {\n        cb(xhr.responseText)\n        performance.mark('xhr-end'+marker)\n        performance.measure('xhr'+marker, 'xhr-start'+marker, 'xhr-end'+marker)\n      } else {\n        console.error('Error loading webfont: server responded with code %s at %s',\n          xhr.status, address)\n      }\n    }\n  }\n  xhr.open('GET', address)\n  try {\n    xhr.send(null)\n  } catch (err) {\n    console.error(err)\n  }\n}</code></pre>\n  </div>\n</div>\n<div class=\"row\">\n  <div class=\"d-flex align-items-center justify-content-between flex-column col-md-4\">\n    <div>\n      <p>\n        The standard google fonts stylesheet contains a number of <span class=\"tm\">@font-face</span> records with CSS properties. The <span class=\"tm\">unicode-range</span> property allows to download fonts only if the page contains characters from that range, and it's annotated just above the record.\n      </p>\n    </div>\n    <img class=\"img-fluid\" alt=\"latin font face animation\" src=\"data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' width='150' height='170'/%3E\" data-io>\n    <noscript>\n      <img class=\"img-fluid\" alt=\"latin font face animation\" src=\"best-google-font-2/animate/fontface.gif\">\n    </noscript>\n  </div>\n  <div class=\"d-flex justify-content-center align-items-center col\">\n    <pre id=\"c1d47\"><code class=\"css hljs\">/* latin-ext */\n@font-face {\n  font-family: 'Gentium Basic';\n  font-style: italic;\n  font-weight: 400;\n  font-display: swap;\n  src:  local('GentiumBasic-Italic'), url(woff2) format('https://woff2');\n  unicode-range: U+0100-024F, U+0259, ...etc;\n}\n/* latin */\n@font-face {\n  font-family: 'Gentium Basic';\n  font-style: italic;\n  font-weight: 400;\n  font-display: swap;\n  src: local('GentiumBasic-Italic'), url(woff2) format('https://woff2');\n  unicode-range: U+0000-00FF, U+0131, ...etc;\n}</code></pre>\n  </div>\n</div>\n\n<div class=\"row\">\n  <div class=\"order-1 order-md-2 d-flex align-items-center justify-content-between flex-column col-md-4\">\n    <div>\n      <p>\n        Our stylesheet parsing function uses a regex to extract URLs with unicode ranges of fonts, and creates an array like <span class=\"tm\">[{ font: 'https://woff2', range: /[regex]/ }]</span> for each font it found in the stylesheet.\n      </p>\n      <p>The <span class=\"tm\">U+0000-00FF,U+0131,...</span> range will become <span class=\"tm\">[\\u0000-\\u00FF\\\\u0131...]</span> JS regex.</p>\n    </div>\n  </div>\n  <div class=\"order-2 order-md-1 d-flex justify-content-center align-items-center col\">\n    <pre id=\"ccdbf\"><code class=\"javascript hljs\">function parseBody(result) {\n  const re = /url\\((.+?)\\).*?;\\s+unicode-range: (.+?);/g\n  let ranges = {}\n  const fonts = []\n  let a\n  while((a = re.exec(result))) {\n    const u = a[1]\n    const range = a[2]\n    fonts.push({ url: u, range })\n    ranges[range] = 1\n  }\n  ranges = Object.keys(ranges).reduce((acc, range) =&gt; {\n    const reg = range\n      .split(/,\\s/)\n      .map((r) =&gt; r.replace('U+', '\\\\u').replace('-', '-\\\\u'))\n      .join('').toLowerCase()\n    acc[range] = new RegExp(`[${reg}]`)\n    return acc\n  }, {})\n  // ...</code></pre>\n  </div>\n</div>\n\n<div class=\"row\" id=\"two-scenarios\">\n  <div class=\"order-1 order-md-2 d-flex align-items-center justify-content-between flex-column col-md-4\">\n    <div>\n      <p>There are 2 scenarios when we'll get the stylesheet ready:</p>\n      <p>\n         A) <em>after</em> HTML parsing, when <span class=\"tm\">body</span> is available. By running the regex against body's text content, we can figure out if we don't use <strong>latin-ext</strong> on the page, and just pass the unicode range for <strong>latin</strong> characters. This way, we don't have to download each single font in the stylesheet, wasting data; <em>and</em>\n      </p>\n      <p>\n         B) <em>prior</em> to HTML parsing, which can happen because there's another stylesheet blocking the render, and/or because the connection is very fast. Here, we wouldn't know the unicode ranges that are present on the page, therefore they have to be supplied as additional information. \n      </p>\n    </div>\n    <img class=\"img-fluid\" alt=\"body not ready animation\" src=\"data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' width='150' height='296'/%3E\" data-io>\n    <noscript>\n      <img class=\"img-fluid\" alt=\"body not ready animation\" src=\"best-google-font-2/animate/head2.gif\">\n    </noscript>\n  </div>\n  <div class=\"order-2 order-md-1 d-flex justify-content-center align-items-center col\">\n    <pre id=\"ccdbf1\"><code class=\"javascript hljs\">  // ..\n  const body = document.body ? document.body.textContent : ''\n  const validRanges = body ? Object.keys(ranges).reduce((acc, range) =&gt; {\n\n    // case A) body is loaded, test it against the regex.\n    const reg = ranges[range]\n    const valid = reg.test(body)\n    if (valid) acc[range] = true\n    return acc\n  }, {}) : Object.keys(ranges).reduce((acc, range) =&gt; {\n\n    // case B) body is not available, fallback to supplied ranges.\n    const valid = range in defaultRanges\n    if (valid) acc[range] = true\n    return acc\n  }, {})\n\n  // filter only fonts we need\n  urls = fonts.filter(({ range }) =&gt; {\n    return range in validRanges\n  }).map(({ url: u }) =&gt; u)\n\n  // if ranges are not supplied, and we're in case A, just add the stylesheet.\n  // we loose the advantage of eliminating continuous reflows due to fonts\n  // arriving independently at different times.\n  if (!urls.length) return loadedCb()\n\n  // preload fonts via link elements\n  // each appendChild has a cost, so bundle them into a fragment.\n  const fragment = document.createDocumentFragment()\n  urls.forEach((address, i) =&gt; {\n    const link = document.createElement('link')\n    link.href = address\n    link.rel = 'preload'\n    link.as = 'font'\n    const j = i + 1\n    performance.mark('link-preload-start'+j)\n    link.onload = () =&gt; loadedCb(j)\n    link.setAttribute('crossorigin', true)\n    fragment.appendChild(link)\n  })\n  document.head.appendChild(fragment)\n}</code></pre>\n  </div>\n</div>\n\n<div class=\"row\">\n  <div class=\"d-flex align-items-center justify-content-between flex-column col-md-4\">\n    <div>\n      <p>\n        Finally I add some logic to keep track of parallel preloads and to embed the stylesheet when they all arrive, and write the <span class=\"tm\">startPreload</span> function to wire all functions up together.\n      </p>\n      <p>\n        The argument <span class=\"tm\">i</span> would not be set if there were no valid URLs to load, e.g., in case B when no unicode ranges were passed, therefore I skip performance measurement there. The measure function will throw runtime error instead of warning, so one should be careful with it.\n      </p>\n    </div>\n    <img class=\"img-fluid\" alt=\"3 Fonts shishi-odoshi animation.\" src=\"data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' width='350' height='292'/%3E\" data-io>\n    <noscript>\n      <img class=\"img-fluid\" alt=\"3 Fonts shishi-odoshi animation.\" src=\"best-google-font-2/animate/lever.gif\">\n    </noscript>\n  </div>\n  <div class=\"d-flex justify-content-center align-items-center col\">\n    <pre id=\"ccdbf2\"><code class=\"javascript hljs\">let FONT_CSS\nlet urls = []\nlet loaded = 0\n\n/**\n * @param {number} [i] The index of the link\n */\nfunction loadedCb(i) {\n  if (i) {\n    performance.mark('link-preload-end'+i)\n    performance.measure('link-preload', 'link-preload-start'+i, 'link-preload-end'+i)\n  }\n  loaded++\n  if (loaded &gt;= urls.length) {\n    const style = document.createElement('style')\n    style.innerHTML = FONT_CSS\n    document.head.appendChild(style)\n\n    performance.mark('agf-end')\n    performance.measure('@lemuria/font', 'agf-start', 'agf-end')\n  }\n}\n\n// the entry main: fetch CSS and call parseBody,\n// which will call loadedCb for each font.\nfunction startPreload(linkEl, marker = 'link') {\n  const href = linkEl.href\n  fetchStylesheet(href, (res) =&gt; {\n    FONT_CSS = res\n    parseBody(FONT_CSS)\n  }, '-' + marker)\n}\n\n// kick in advanced google font preloading!\nstartPreload({ href: FONT }, 'js')</code></pre>\n  </div>\n</div>\n\n<p>I could have used the <span class=\"tm\">fetch</span> instead of XHR since it's 2019, however I would need to add a polyfill and transpile async code. There's no performance difference between <span class=\"tm\">fetch</span> and <span class=\"tm\">XMLHttpRequest</span> APIs. One observation, is that with <span class=\"tm\">fetch</span>, data could be streamed, so if the response arrived in chunks, I could extract fonts as they come, but because the stylesheet is so small (&lt; 1kb), streaming is unnecessary. I've made a package called <a\n   title=\"Loads A Web Font Stylesheet (e.g., Google Fonts) Without Render Blocking And Multiple Layout Updates.\" class=\"NPMBadge\" href=\"https://www.npmjs.com/package/@lemuria/font\">\n   <span class=\"a\">@lemuria/font</span><span class=\"b\">1.0.4</span></a> with this code which I ran through <em>Google Closure Compiler</em>, so let's update our page:</p>\n\n<pre id=\"c6ce5\"><code class=\"xml hljs\">&lt;head&gt;\n  &lt;link rel=\"dns-prefetch\" href=\"//fonts.googleapis.com\"&gt;\n  &lt;link rel=\"preconnect\" href=\"https://fonts.gstatic.com\" crossorigin&gt;\n  &lt;link rel=\"preload\" href=\"https://fonts.googleapis.com/css?display=swap&amp;family=Gentium+Basic:400,400i,700|Limelight\" as=\"fetch\"&gt;\n  &lt;script&gt;\n    (function(){window[\"@lemuria/font\"]=function(q,k){function x(a){for(var f=/url\\((.+?)\\).*?;\\s+unicode-range: (.+?);/g,b={},d=[],h;h=f.exec(a);){var r=h[2];d.push({url:h[1],a:r});b[r]=1}b=Object.keys(b).reduce(function(c,e){var g=e.split(/,\\s/).map(function(l){return l.replace(\"U+\",\"\\\\u\").replace(\"-\",\"-\\\\u\")}).join(\"\").toLowerCase();c[e]=new RegExp(\"[\"+g+\"]\");return c},{});var t=document.body?document.body.textContent:\"\",y=t?Object.keys(b).reduce(function(c,e){b[e].test(t)&amp;&amp;(c[e]=!0);return c},{}):Object.keys(b).reduce(function(c,\n    e){e in k&amp;&amp;(c[e]=!0);return c},{});m=d.filter(function(c){return c.a in y}).map(function(c){return c.url});if(!m.length)return u();var v=document.createDocumentFragment();m.forEach(function(c,e){var g=document.createElement(\"link\");g.href=c;g.rel=\"preload\";g.as=\"font\";var l=e+1;performance.mark(\"link-preload-start\"+l);g.onload=function(){return u(l)};g.setAttribute(\"crossorigin\",!0);v.appendChild(g)});document.head.appendChild(v)}k=void 0===k?{}:k;var n=document.createElement(\"link\");if(function(a,\n    f){if(!a||!a.supports)return!1;try{return a.supports(f)}catch(b){return!1}}(n.relList,\"preload\")){var z=function(a,f,b){b=void 0===b?\"\":b;performance.mark(\"xhr-start\"+b);var d=new XMLHttpRequest;d.onreadystatechange=function(){4==d.readyState&amp;&amp;(200==d.status?(f(d.responseText),performance.mark(\"xhr-end\"+b),performance.measure(\"xhr\"+b,\"xhr-start\"+b,\"xhr-end\"+b)):console.error(\"Error loading webfont: server responded with code %s at %s\",d.status,a))};d.open(\"GET\",a);try{d.send(null)}catch(h){console.error(h)}};\n    performance.mark(\"agf-start\");var p;(function(a,f){z(a.href,function(b){p=b;x(p)},\"-\"+(void 0===f?\"link\":f))})({href:q},\"js\");var m=[],w=0,u=function(a){a&amp;&amp;(performance.mark(\"link-preload-end\"+a),performance.measure(\"link-preload\",\"link-preload-start\"+a,\"link-preload-end\"+a));w++;w&gt;=m.length&amp;&amp;(a=document.createElement(\"style\"),a.innerHTML=p,document.head.appendChild(a),performance.mark(\"agf-end\"),performance.measure(\"@lemuria/font\",\"agf-start\",\"agf-end\"))}}else n.rel=\"stylesheet\",n.href=q,document.head.appendChild(n)};}).call(this);\n\n    window['@lemuria/font']\n      ('https://fonts.googleapis.com/css?display=swap&amp;family=Gentium+Basic:400,400i,700|Limelight')\n  &lt;/script&gt;\n&lt;/head&gt;</code></pre>\n\n<p>I've left plenty of performance markers, but there's a version that doesn't have them for smaller size. What does the resulting timeline look like? Have we solved the problem of throttling fonts' reflows?</p>\n\n</div></div></div>\n<div class=\"container-fluid position-relative\">\n  <div class=\"row\">\n    <div class=\"order-2 d-flex align-items-center justify-content-center flex-column mb-3 p-3 rounded position-relative overflow-hidden col\" id=\"fig-advanced-loading\">\n      <div class=\" Parallax\" data-loading style=\"z-index: -1;\" id=\"c709f1\"></div>\n      <div style=\"z-index: -1;\" class=\"Parallax\"></div>\n      <noscript>\n        <div class=\" Parallax\" style=\"background-image: url(/img/letters/background.png); z-index: -1;\"></div>\n      </noscript>\n      <p class=\"text-center\">\n        <img class=\"border rounded img-fluid\" alt=\"Figure 1: Advanced asynchronous Google Font performance: achieving single reflow.\" src=\"data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' width='761' height='659'/%3E\" data-io>\n        <noscript>\n          <img class=\"border rounded img-fluid\" alt=\"Figure 1: Advanced asynchronous Google Font performance: achieving single reflow.\" src=\"best-google-font-2/graphics/dev8.png\">\n        </noscript>\n      </p>\n      <h5 id=\"figure-1-advanced-asynchronous-google-font-performance-achieving-single-reflow\"\n        class=\"m-0 d-inline-block\" style=\"background: white;\">\n        Figure 1: Advanced asynchronous Google Font performance: achieving single reflow.\n      </h5>\n    </div>\n  </div>\n  <div class=\"position-absolute\" style=\"opacity: 0; top: 1rem; right: 1rem;\" id=\"c0208\">\n    <a class=\"btn btn-danger\" href=\"#\">Go Back</a>\n  </div>\n</div>\n<div class=\"container\"><div class=\"row\"><div class=\"col\">\n\n<div class=\"mb-3 Revision Blue\">\n  <ol style=\"background-image: url('../articles/img/sketch.svg');\">\n    \n      <li>As soon as the page starts parsing, we begin the XHR request, but the CSS as fetch preload resource has already started downloading. The script evaluation takes <em>10ms</em>.</li>\n      <li>The download completes (purple line), but the thread is blocked so that the XHR has to wait until the main thread is free to execute the callback. Fonts don't begin to download but we can't do anything about it. Once the thread is available, the <em>@lemuria/font</em> script inject 4 preload links and assign an <span class=\"tm\">onload</span> listener to each them.</li>\n      <li>When all <span class=\"tm\">onload</span> events have fired, the function adds the stylesheet to DOM as a style. Despite the fact that fonts arrived at different times, we only see one reflow which takes 100ms. The page's <span class=\"tm\">onload</span> event is thus delivered quicker and the users and Google are happy.</li>\n    \n  </ol>\n  <div class=\"position-absolute\" style=\"width: 1rem; bottom: 0px; top: 0px; right: 1rem; border-left: 1px solid #ec6a9d;\">\n    <img src=\"/img/arrows.svg\">\n  </div>\n</div>\n\n<p><em>OK Google</em>, we've achieved the maximum optimisation of your fonts consisting of gathering all fonts to flush them at once together with the stylesheet to have only a single reflow. Let's just see what if there's a render blocking resource, such as an external CSS that would give us some additional time to fetch the web font stylesheet:</p>\n\n</div></div></div>\n<div class=\"container-fluid position-relative\">\n  <div class=\"row\">\n    <div class=\"order-2 d-flex align-items-center justify-content-center flex-column mb-3 p-3 rounded position-relative overflow-hidden col\" id=\"fig-before-body\">\n      <div class=\" Parallax\" data-loading style=\"z-index: -1;\" id=\"c709f2\"></div>\n      <div style=\"z-index: -1;\" class=\"Parallax\"></div>\n      <noscript>\n        <div class=\" Parallax\" style=\"background-image: url(/img/letters/background.png); z-index: -1;\"></div>\n      </noscript>\n      <p class=\"text-center\">\n        <img class=\"border rounded img-fluid\" alt=\"Figure 2: @Lemuria/font parsing starting before body is available without default unicode-ranges.\" src=\"data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' width='761' height='659'/%3E\" data-io>\n        <noscript>\n          <img class=\"border rounded img-fluid\" alt=\"Figure 2: @Lemuria/font parsing starting before body is available without default unicode-ranges.\" src=\"best-google-font-2/graphics/dev9.png\">\n        </noscript>\n      </p>\n      <h5\n        id=\"figure-2-lemuriafont-parsing-starting-before-body-is-available-without-default-unicode-ranges\" class=\"m-0 d-inline-block\" style=\"background: white;\">\n        Figure 2: @Lemuria/font parsing starting before body is available without default unicode-ranges.\n      </h5>\n    </div>\n  </div>\n  <div class=\"position-absolute\" style=\"opacity: 0; top: 1rem; right: 1rem;\" id=\"ccb6d\">\n    <a class=\"btn btn-danger\" href=\"#\">Go Back</a>\n  </div>\n</div>\n<div class=\"container\"><div class=\"row\"><div class=\"col\">\n\n<div class=\"mb-3 Revision Reverse Blue\">\n  <ol style=\"background-image: url('../articles/img/sketch.svg');\">\n    \n      <li>The advanced font loading script is executed, and taps into the preload download, but by the time the XHR is finished, the script cannot find <span class=\"tm\">body</span> and there are no default unicode ranges. It falls back to essentially just appending a link tag with the style to the head.</li>\n      <li>The additional external stylesheet for our page begins to parse only now.</li>\n      <li>Fonts arrive one by one in 3 different waves.</li>\n    \n  </ol>\n  <div class=\"position-absolute\" style=\"width: 1rem; bottom: 0px; top: 0px; right: 1rem; border-left: 1px solid #ec6a9d;\">\n    <img src=\"/img/arrows.svg\">\n  </div>\n</div>\n\n<p>In this experiment, instead of inlining the page's style, I added a link to it, so that the browser had to download it. Although such download happens really quickly, the page nevertheless is slowed down by much more than just the download time. Unlike in the previous case, now when the <span class=\"tm\">@lemuria/font</span> function has fetched the stylesheet and calls the XHR callback, the body is NOT yet available because the parsing has not started. This shows that it's not just the download job that increases the start up time for external stylesheets, but their loading time also: <em>total: 84.12 ms (15.12 ms network transfer + 69.01 ms resource loading)</em> which would have been <em>0ms</em> had the stylesheet been embedded and present for parsing immediately.</p>\n\n<p>Again, this is my 2008 slow CPU MacBook but the idea is that when executing a script in the head, the body is not yet available since no parsing has begun. But the experiment above clearly shows that even though the body is not ready, we still could have had downloaded an external resource, for example a style, as browsers are really serious about such <strong>critical</strong> path assets due to the fact that they are REQUIRED to paint ANY content on a page. In the case of advanced google font technique, even though the preload is defined as <strong>\"fetch\"</strong>, it's still considered to be a CSS and has the highest download priority. In fact, it downloads so fast, the browser hasn't even begun properly parsing the page! In spite that it's an old laptop I was testing it on, <em>Lighthouse</em> does apply CPU throttling when producing reports, and so probably does <em>Google</em> for its page speed ranking measurements, so such experiments are worthwhile investments of time into improving the web development skill and understanding page speed optimisation principles. If your <strong>performance</strong> tab in the dev console is covered with cobweb, I'd suggest it's time to acknowledge its importance in today's competitive world of front-end development requiring high competence.</p>\n   <!-- because browsers take responsibility to spin off this external downloads as soon as they can, as it's <strong>critical</strong> resource paths, yet  -->\n\n<p>What the experiment showed was that because there were no default <span class=\"tm\">unicode-ranges</span> to apply, the stylesheet was just embedded into the DOM as a fallback, so that the font flushing method didn't work. I'll show how to use unicode ranges in a sec, let's just take a short break.</p>\n\n<p class=\"SectionBreak\">\n  <a title=\"Back To Top\" href=\"#top\">\n    <img alt=\"section break\"\n      src=\"data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' width='40' height='15'/%3E\" data-io>\n    <noscript><img alt=\"section break\" src=\"/section-breaks/0.svg\"></noscript></a>\n</p>\n\n\n\n<h3 id=\"non-blocking\" class=\"d-md-none\">Non-Blocking Proof</h3>\n\n<div class=\"position-relative row\">\n  <div class=\"order-1 d-flex align-items-center justify-content-center flex-column col-lg-6\">\n    <h3 id=\"non-blocking-proof\" class=\"d-none d-md-block\">Non-Blocking Proof</h3>\n      <p>From looking at the previous graph, for a scary moment I thought that I might be giving wrong advice when saying to append a <span class=\"tm\">link</span> tag dynamically into the head, and it will actually block the page from rendering. This is because on the previous <a data-smooth href=\"#fig-before-body\">Fig 2</a> (don't be afraid to click, we have a user-friendly scroll with a back button), there are some gaps in the timeline after the web font stylesheet is inserted, but before the external CSS is parsed, that could indicate that the page was render-blocked.</p>\n      <p>However, it's not the case as shown <span id=\"Above\">below</span><span id=\"OnLeft\">on the left</span>: the parse HTML goes in parallel with stylesheet loading. My interpretation of those gaps in past is that the browser has to pause to parse the external style, allowing some async JS to report to the main thread via callbacks (e.g., on <a data-smooth href=\"#fig-before-body\">Fig 2</a>, XHR is completed quicker compared to the <a data-smooth href=\"#fig-advanced-loading\">Fig 1</a>, where it had to wait for the main thread to unblock since there were no gaps).</p>\n  </div>\n  <div class=\"order-2 d-flex align-items-center justify-content-center flex-column mb-3 p-3 rounded position-relative overflow-hidden col-lg-6\" id=\"fig-9848\">\n    <div class=\" Parallax\" data-loading style=\"z-index: -1;\" id=\"c709f\"></div>\n    <div style=\"z-index: -1;\" class=\"Parallax\"></div>\n    <noscript>\n      <div class=\" Parallax\" style=\"background-image: url(/img/letters/background.png); z-index: -1;\"></div>\n    </noscript>\n    <p class=\"text-center\">\n      <img class=\"border rounded img-fluid\" alt=\"Figure 3: Dynamic insertion of a link with JS does not block page render.\" src=\"data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' width='639' height='486'/%3E\" data-io>\n      <noscript>\n        <img class=\"border rounded img-fluid\" alt=\"Figure 3: Dynamic insertion of a link with JS does not block page render.\" src=\"best-google-font-2/graphics/dev-check.gif\">\n      </noscript>\n    </p>\n    <h5 id=\"figure-3-dynamic-insertion-of-a-link-with-js-does-not-block-page-render\"\n      class=\"m-0 d-inline-block\" style=\"background: white;\">\n      Figure 3: Dynamic insertion of a link with JS does not block page render.\n    </h5>\n  </div>\n  <div class=\"position-absolute\" style=\"opacity: 0; top: 1rem; right: 1rem;\" id=\"ce513\">\n    <a class=\"btn btn-danger\" href=\"#\">Go Back</a>\n  </div>\n</div>\n\n<p>I mean, my explanation around \"pauses\" is probably not 100% accurate to what's going internally, but I think it gives a picture that WITHOUT external resources the parsing proceeds to rendering in one continuous \"stroke\", whereas WITH external styles, there will be gaps. Codewise, essentially all I've done is added an external stylesheet dynamically, but throttled it server-side with a middleware function. Because the page continued to render, it's safe to say that adding a link with JS in the head will not block the main thread.</p>\n\n<div class=\"row\">\n  <div class=\"col-md-6\">\n    <pre id=\"c6ce52\"><code class=\"xml hljs\">&lt;head&gt;\n&lt;link rel=\"preload\" href=\"/throttle.css\" as=\"style\"&gt;\n  &lt;script&gt;\n    const link = document.createElement('link')\n    link.href = '/throttle.css'\n    link.rel = 'stylesheet'\n    performance.mark('add-stylesheet')\n    document.head.appendChild(link)\n    link.onload = () =&gt; {\n      performance.measure('stylesheet-onload', 'add-stylesheet');\n    }\n  &lt;/script&gt;\n&lt;/head&gt;</code></pre>\n  </div>\n  <div class=\"col-md-6\">\n    <pre id=\"ccdbf3\"><code class=\"javascript hljs\">// Koa middleware\nasync function throttle(ctx, next){\n  if (ctx.path == '/throttle.css') {\n    await new Promise(r =&gt; setTimeout(r, 500))\n    ctx.type = 'text/css'\n    ctx.body = ''\n  }\n  await next()\n}</code></pre>\n    <p style=\"font-size: small;\">If you're a fan of Koa like I am, have a look at our <em>Koa</em> Fork, <a title=\"The Koa2 Fork Optimized With Closure Compiler That Has Just 1 Dependency (mime-db).\"\n   class=\"NPMBadge\" href=\"https://www.npmjs.com/package/@goa/koa\">\n   <span class=\"a\">@Goa/Koa</span><span class=\"b\">1.1.5</span></a> which is 100% Koa compiled and optimised with <em>Google Closure Compiler</em> to just one dependency (which is <span class=\"tm\">mime-db</span>). Want to find our more about revolutionary way of compiling <em>Node.JS</em> package from <em>Art Deco</em>? Be sure to subscribe to receive info about new age methods of modern web development.</p>\n  </div>\n</div>\n\n<p class=\"SectionBreak\">\n  <a title=\"Back To Top\" href=\"#top\">\n    <img alt=\"section break\"\n      src=\"data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' width='40' height='13'/%3E\" data-io>\n    <noscript><img alt=\"section break\" src=\"/section-breaks/1.svg\"></noscript></a>\n</p>\n\n<h3 id=\"unicode-range-application\">Unicode Range Application</h3>\n\n<p>So finally, let me show a case with an external stylesheet, and with a unicode-range. The unicode-range can be looked up in the Google's servers response, but I'm quite sure they are pretty static so you wouldn't have to do it often (but keep an eye out for them). The range must be set as a string key without the last <span class=\"tm\">;</span>. Multiple ranges can be specified for fonts targeting different language sets, but I'm just using the <span class=\"tm\">latin</span> one here, because there are no special characters on the page that would require the extended version.</p>\n\n<pre id=\"c6ce51\"><code class=\"xml hljs\">&lt;head&gt;\n  &lt;link rel=\"preload\" crossorigin as=\"fetch\"\n    href=\"https://fonts.googleapis.com/css?display=swap&amp;family=Gentium+Basic:400,400i,700|Limelight\"&gt;\n  &lt;script&gt;\n    /* @lemuria/font source code goes here ... */\n    var range = 'U+0000-00FF, U+0131, U+0152-0153, U+02BB-02BC, U+02C6, U+02DA, U+02DC, U+2000-206F, ' +\n                'U+2074, U+20AC, U+2122, U+2191, U+2193, U+2212, U+2215, U+FEFF, U+FFFD'\n    window['@lemuria/font']\n      ('https://fonts.googleapis.com/css?display=swap&amp;family=Gentium+Basic:400,400i,700|Limelight', {\n        [range]: true, // latin range\n      })\n  &lt;/script&gt;\n&lt;/head&gt;</code></pre>\n\n</div></div></div>\n<div class=\"container-fluid position-relative\">\n  <div class=\"row\">\n    <div class=\"order-2 d-flex align-items-center justify-content-center flex-column mb-3 p-3 rounded position-relative overflow-hidden col\" id=\"fig-lemuria-font\">\n      <div class=\" Parallax\" data-loading style=\"z-index: -1;\" id=\"c709f3\"></div>\n      <div style=\"z-index: -1;\" class=\"Parallax\"></div>\n      <noscript>\n        <div class=\" Parallax\" style=\"background-image: url(/img/letters/background.png); z-index: -1;\"></div>\n      </noscript>\n      <p class=\"text-center\">\n        <img class=\"border rounded img-fluid\" alt=\"Figure 4: @Lemuria/font with unicode-range info allows to download fonts in parallel to the main thread.\" src=\"data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' width='817' height='597'/%3E\" data-io>\n        <noscript>\n          <img class=\"border rounded img-fluid\" alt=\"Figure 4: @Lemuria/font with unicode-range info allows to download fonts in parallel to the main thread.\" src=\"best-google-font-2/graphics/dev10.png\">\n        </noscript>\n      </p>\n      <h5\n        id=\"figure-4-lemuriafont-with-unicode-range-info-allows-to-download-fonts-in-parallel-to-the-main-thread\" class=\"m-0 d-inline-block\" style=\"background: white;\">\n        Figure 4: @Lemuria/font with unicode-range info allows to download fonts in parallel to the main thread.\n      </h5>\n    </div>\n  </div>\n  <div class=\"position-absolute\" style=\"opacity: 0; top: 1rem; right: 1rem;\" id=\"ceba0\">\n    <a class=\"btn btn-danger\" href=\"#\">Go Back</a>\n  </div>\n</div>\n<div class=\"container\"><div class=\"row\"><div class=\"col\">\n\n<div class=\"mb-3 Revision Blue\">\n  <ol style=\"background-image: url('../articles/img/sketch.svg');\">\n    \n      <li>The font script begins the XHR request as soon as HTML starts to parse. It might look like the thread is blocked because the browser is not doing anything during the XHR, however it's not so otherwise there would be a long solid orange line saying \"Evaluating JS\", but there's just a gap. The browser is doing something, but there's no info to it. The XHR is async so it's not blocking the thread.<br><br></li>\n      <li>The XHR is finished but the body is not present. Because we've passed the desired <span class=\"tm\">unicode-range</span>, the script filters out fonts based on it and inserts 4 preload links, after which they begin to download immediately. This allows to parallelise their download with the initial render.<br><br></li>\n      <li>Once the thread is freed (the <span style=\"background:blue; color:white\" class=\"px-2\"><abbr title=\"Dom Content Loaded\">DCL</abbr></span> event), there's a bit of work to do for other JS scripts on the page, after which the web font stylesheet is applied. Notice there's only <em>150ms</em> delay between the <span style=\"background:green; color:white\" class=\"px-2\"><abbr title=\"First Paint\">FP</abbr></span> and fonts being applied (but not painted) which gives us the fastest FOUT so far, compared to all previous situations when we were only started to download fonts at this point because it was when the thread became free.</li>\n    \n  </ol>\n  <div class=\"position-absolute\" style=\"width: 1rem; bottom: 0px; top: 0px; right: 1rem; border-left: 1px solid #ec6a9d;\">\n    <img src=\"/img/arrows.svg\">\n  </div>\n</div>\n\n<p>Cool, I think we've optimised as much as possible out of <em>Google Fonts</em>. The final version enables to insert the stylesheet before the initial layout, and also downloads fonts in parallel to the main thread which is busy rendering. Practically, this is only possible if the device is pretty slow and/or there are render blocking resources that will postpone the parsing for some time long enough for the web font stylesheet preload to complete, but nonetheless this technique is still applicable, in particular to heavier pages that require more time for parsing and initial / following layouts (whereas before, there could be 4 reflows - 1 for stylesheet injection and 3 for each of the fonts arriving independently, now it's only one).</p>\n  <!-- In case there are none, I've tried the following trick: -->\n\n<!-- <span class=\"tm\">`</span>html -->\n<!-- <head> -->\n  <!-- ... -->\n  <!-- <link href=\"data:text/css;charset=utf-8,\" rel=\"stylesheet\"> -->\n<!-- </head> -->\n<!-- <span class=\"tm\">`</span> -->\n\n<!-- <p>\n  In words, I added a data-url link in hope that the browser will pause to download it which will give the XHR callback a chance to fire (it <a\n   onclick=\"document.querySelector(this.getAttribute('href')).scrollIntoView({behavior: 'smooth'}); return false\" href=\"#fig-advanced-loading\">\n   does not fire</a> if there are no external resources), however that didn't work ü§∑‚Äç‚ôÄÔ∏è. Let me wrap up to conclusions.\n</p> -->\n\n<p class=\"SectionBreak\">\n  <a title=\"Back To Top\" href=\"#top\">\n    <img alt=\"section break\"\n      src=\"data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' width='40' height='13'/%3E\" data-io>\n    <noscript><img alt=\"section break\" src=\"/section-breaks/2.svg\"></noscript></a>\n</p>\n\n<h2 id=\"comparison\">Comparison</h2>\n\n<p>Google Fonts are great because it's really easy to embed them and the service provides a variety of good-looking web fonts. The standard sync loading with a simple link tag, however, will lock the main thread and not prevent the page (even HTML won't start parsing) which we would like to avoid. Moreover, fonts will load independently, and each time they will cause a reflow of the page, which slows down the <span class=\"px-2\" style=\"background:red; color:white\"><abbr title=\"Load\">L</abbr></span> event delivery and frustrates the user. In summary, we've gone through the following stages for optimisation from the sync loading:</p>\n\n<h4 id=\"1-async-loading\" class=\"text-center\">1) Async Loading</h4>\n<hr>\n\n<div class=\"position-relative float-md-right pl-3 pb-3\" id=\"c5f46\">\n  <img class=\"img-fluid\" alt=\"async google font animation\" src=\"data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' width='505' height='299'/%3E\" data-io>\n  <noscript>\n    <img class=\"img-fluid\" alt=\"async google font animation\" src=\"best-google-font-2/graphics/async-google-font.png\">\n  </noscript>\n</div>\n\n<p>Instead of adding a link tag in the markup, we add a simple script to create the link dynamically. This technique allows to transform sync render-blocking loading of resources into async non-blocking loading, and eliminates the Lighthouse warning. We also add a preload link so that the resource begins to download immediately rather than waiting for the script to execute.</p>\n\n<p>We've also looked at another method when instead of a script tag, the <span class=\"tm\">onload</span> attribute on the preload link is used to upgrade the <em>rel</em> from <strong>preload</strong> to <strong>stylesheet</strong>, however as I've shown, this has a disadvantage that if the stylesheet arrives after the initial render, it will cause an expensive reflow, despite the fact that fonts are not even loaded. Therefore I suggest it's better to use the traditional script element right under the preload link.</p>\n\n<h4 id=\"2-advanced-loading\" class=\"text-center\">2) Advanced Loading</h4>\n\n<hr>\n\n<p>Although async loading better than sync one, it's still not perfect, because we still have multiple reflows due to independent font loading. I propose a solution where an Ajax request is made to fetch the stylesheet, extract urls to fonts, preload them, and once they are all ready, embed the stylesheet into DOM.</p>\n\n<div class=\"position-relative float-md-left pr-3 pb-3\" id=\"c228f\">\n  <img class=\"img-fluid\" alt=\"advanced google font animation\" src=\"data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' width='505' height='299'/%3E\" data-io>\n  <noscript>\n    <img class=\"img-fluid\" alt=\"advanced google font animation\" src=\"best-google-font-2/graphics/advanced-google-font.png\">\n  </noscript>\n</div>\n\n<p>Any external CSS will postpone the parsing of HTML until it's received, but not only for the length of its download time, but for the duration of its loading time, which might be much longer than the download one. <span style=\"background:green; color: white\">Therefore when we're talking about maximum optimisation, such as for a landing page of a product, we might want to embed the full stylesheet onto the page so that we don't have to wait for it.</span> The browser treats this case differently and the loading pattern is continuous, i.e., start of parsing leads to layout without any gaps. However, if we have a web portal with multiple pages that share same styles, like a forum, it might not be feasible to embed CSS onto each page. Here, we're not that concerned with making an impression on the user with lightning-fast pages, but just want to deliver content. These are 2 broad cases that each deserving its own treatment.</p>\n\n<p>When there are no external CSS, our script will begin to download XHR, but will probably have to wait until the initial rendering is done to parse it and begin to download fonts. When there are external CSS that blocked the page, the script might get a chance to parse the stylesheet, but it won't have information about the <span class=\"tm\">body</span>'s content to correctly apply <span class=\"tm\">unicode-range</span>, therefore we can supply that info manually to prevent unused fonts from extended ranges from downloading. In the latter case, we will be able to download fonts in parallel to the main thread doing the layout job, and apply the style right after the thread is freed, that is after the <span style=\"background:blue; color:white\" class=\"px-2\"><abbr title=\"Dom Content Loaded\">DCL</abbr></span> event. This scenario is when the loading is the fastest.</p>\n\n<p>There might be some disadvantages to the method:</p>\n\n<ol>\n  <li>The script might take up some time to evaluate and if it can create preload links before parsing of HTML, it will also take additional time to insert them into DOM (takes 5-20ms) on my computer. We might have saved some time because all fonts were injected at once, but that time was after first paint, whereas now we might blocking the browser for about 30-40ms before the first paint (not so bad if XHR finishes after the initial render).</li>\n  <li>If there is a really large number of fonts, we will have to wait for each one of them to download, which might not be desirable. However in that case, we can break up the fonts into multiple batches by calling the <span class=\"tm\">@lemuria/font</span> function multiple times.</li>\n</ol>\n\n<p>On the other hand, the <span class=\"tm\">@lemuria/font</span> script works as a polyfill for <span class=\"tm\">display:swap</span> which is not available for Edge. However, because it embeds fonts with <em>preload</em> links, it will not work on the IE/Edge12-16/Firefox. I thought about downloading fonts with XHR to prime the network cache, however after I downloaded them this way, and then injected the web font stylesheet referencing them, they were re-downloaded. A solution to this would be to embed fonts into the webpage with <span class=\"tm\">data:application/font</span> url, however that would trigger <span class=\"tm\">data:</span> string parsing and slow down the page.</p>\n\n<div class=\"row\">\n  <div class=\"order-1 order-md-2 col-md-6\">\n    <p>\n      <a\n        title=\"Loads A Web Font Stylesheet (e.g., Google Fonts) Without Render Blocking And Multiple Layout Updates.\" class=\"NPMBadge\" href=\"https://www.npmjs.com/package/@lemuria/font\">\n        <span class=\"a\">@lemuria/font</span><span class=\"b\">1.0.4</span></a> package is available from NPM, and exports functions that could be added to a server-side rendered webpage. The source code of the function for manual injection can be copied from <a href=\"https://github.com/kumarikandam/font\">Github</a>. The check for <span class=\"tm\">preload</span> support is done the following way, <a target=\"_blank\" rel=\"noopener\" style=\"color: #e33a2c !important; text-decoration: underline;\"\n   href=\"https://www.smashingmagazine.com/2016/02/preload-what-is-it-good-for/\">\n   <nobr><img style=\"max-height:1em; margin-right:-0.2em;vertical-align: top;\n           margin-top: .2em;\"\n  alt=\"S\" data-io>\n<noscript>\n  <img style=\"max-height:1em; margin-right:-0.2em;vertical-align: top;\n             margin-top: .2em;\"\n    alt=\"S\" src=\"best-google-font-2/graphics/smashing.png\">\n</noscript>uggested by preload</nobr></a> contributor to Chrome.\n    </p>\n  </div>\n  <div class=\"order-2 order-md-1 col-md-6\">\n    <pre id=\"ccdbf4\"><code class=\"javascript hljs\">function DOMTokenListSupports(tokenList, token) {\n  if (!tokenList || !tokenList.supports) {\n    return false\n  } try { return tokenList.supports(token) } catch (e) {\n    return false }\n}\nconst link = document.createElement('link')\nconst linkSupportsPreload = DOMTokenListSupports(link.relList, 'preload')</code></pre>\n  </div>\n</div>\n\n<p class=\"SectionBreak\">\n  <a title=\"Back To Top\" href=\"#top\">\n    <img alt=\"section break\"\n      src=\"data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' width='28' height='9'/%3E\" data-io>\n    <noscript><img alt=\"section break\" src=\"/section-breaks/3.svg\"></noscript></a>\n</p>\n\n<h2 id=\"when-do-fonts-begin-to-download\">When Do Fonts Begin To Download?</h2>\n\n<p>I should mention that the best possible course of action would of course be to preload fonts using a preload link without any scripting. However, that's a different context entirely since this article focuses specifically on <em>Google Fonts</em> optimisation. Their servers will return different urls for different browsers, therefore we can't just copy and paste them in the preload link, additionally their fonts evolve and change versions. The advanced google font loading solution is the simplest scripting solution to kicking off font preload as soon as possible, and eliminating multiple render blocks.</p>\n\n<p>Moreover, in the previous article as well as here I've seen results like in <a data-smooth href=\"#fig-before-body\">Fig 2</a> which showed that fonts didn't begin to download before the first <span style=\"background:#A66EEF\">Recalculate Styles</span> even if the stylesheet was downloaded alright. The last experiment was to embed the stylesheet manually with a <span class=\"tm\">&lt;style&gt;/* contents of google font stylesheet */&lt;/style&gt;</span> tag onto the page and see its performance. There are no external resources and the page load should proceed seamlessly from parsing to layout.</p>\n\n<pre id=\"c1602\"><code class=\"xml hljs\">&lt;head&gt;\n  &lt;link rel=\"dns-prefetch\" href=\"//fonts.googleapis.com\"&gt;\n  &lt;link rel=\"preconnect\" href=\"https://fonts.gstatic.com\" crossorigin&gt;\n\n  &lt;style&gt;\n    /* latin-ext */\n    @font-face {\n      font-family: 'Gentium Basic';\n      font-style: italic;\n      font-weight: 400;\n      font-display: swap;\n      src: local('Gentium Basic Italic'), local('GentiumBasic-Italic'), url(https://fonts.gstatic.com/s/gentiumbasic/v11/WnzjHAw9aB_JD2VGQVR80We3LAi5hBo7QoCBZCxP.woff2) format('woff2');\n      unicode-range: U+0100-024F, U+0259, U+1E00-1EFF, U+2020, U+20A0-20AB, U+20AD-20CF, U+2113, U+2C60-2C7F, U+A720-A7FF;\n    }\n    /* etc */\n&lt;/style&gt;</code></pre>\n\n</div></div></div>\n<div class=\"container-fluid position-relative\">\n  <div class=\"row\">\n    <div class=\"order-2 d-flex align-items-center justify-content-center flex-column mb-3 p-3 rounded position-relative overflow-hidden col\" id=\"fig-74268\">\n      <div class=\" Parallax\" data-loading style=\"z-index: -1;\" id=\"c709f4\"></div>\n      <div style=\"z-index: -1;\" class=\"Parallax\"></div>\n      <noscript>\n        <div class=\" Parallax\" style=\"background-image: url(/img/letters/background.png); z-index: -1;\"></div>\n      </noscript>\n      <p class=\"text-center\">\n        <img class=\"border rounded img-fluid\" alt=\"Figure 5: Embedding web fonts stylesheet manually shows when fonts begin to download.\" src=\"data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' width='671' height='522'/%3E\" data-io>\n        <noscript>\n          <img class=\"border rounded img-fluid\" alt=\"Figure 5: Embedding web fonts stylesheet manually shows when fonts begin to download.\" src=\"best-google-font-2/graphics/dev11.gif\">\n        </noscript>\n      </p>\n      <h5 id=\"figure-5-embedding-web-fonts-stylesheet-manually-shows-when-fonts-begin-to-download\"\n        class=\"m-0 d-inline-block\" style=\"background: white;\">\n        Figure 5: Embedding web fonts stylesheet manually shows when fonts begin to download.\n      </h5>\n    </div>\n  </div>\n  <div class=\"position-absolute\" style=\"opacity: 0; top: 1rem; right: 1rem;\" id=\"c6965\">\n    <a class=\"btn btn-danger\" href=\"#\">Go Back</a>\n  </div>\n</div>\n<div class=\"container\"><div class=\"row\"><div class=\"col\">\n\n<p>The performance graph clearly shows that although urls to fonts are there on the page, they don't begin to download prior to the first style calculation. If people were coming for a job interview at <a href=\"https://www.artd.eco\">Art Deco&trade;</a>, I would potentially ask them this question to find out if they read my article ;) Apart from this interesting observation, the conclusion is that the Advanced Google Font method I've introduced here is even better than what the browser can offer natively, because it's able to begin to download fonts even before parsing starts. It does it by extracting urls from the stylesheet, if it arrives quickly enough (see <a data-smooth href=\"#two-scenarios\">case B</a>), as proven on <a data-smooth href=\"#fig-lemuria-font\">Fig 4</a>.</p>\n\n<p class=\"SectionBreak\">\n  <a title=\"Back To Top\" href=\"#top\">\n    <img alt=\"section break\"\n      src=\"data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' width='28' height='9'/%3E\" data-io>\n    <noscript><img alt=\"section break\" src=\"/section-breaks/4.svg\"></noscript></a>\n</p>\n\n<h2 id=\"list-of-figures\">List Of Figures</h2>\n\n<div class=\"mb-3 Revision d-inline-block\">\n  <ol style=\"background-image: url('../articles/img/sketch-yellow.svg');\">\n    \n      <li>\n        <a data-smooth href=\"#fig-advanced-loading\">\n          Advanced asynchronous Google Font performance: achieving single reflow.</a>\n      </li>\n      <li>\n        <a data-smooth href=\"#fig-before-body\">\n          @Lemuria/font parsing starting before body is available without default unicode-ranges.</a>\n      </li>\n      <li>\n        <a data-smooth href=\"#fig-9848\">\n          Dynamic insertion of a link with JS does not block page render.</a>\n      </li>\n      <li>\n        <a data-smooth href=\"#fig-lemuria-font\">\n          @Lemuria/font with unicode-range info allows to download fonts in parallel to the main thread.</a>\n      </li>\n      <li>\n        <a data-smooth href=\"#fig-74268\">\n          Embedding web fonts stylesheet manually shows when fonts begin to download.</a>\n      </li>\n    \n  </ol>\n  <div class=\"position-absolute\" style=\"width: 1rem; bottom: 0px; top: 0px; right: 1rem; border-left: 1px solid #ec6a9d;\">\n    <img src=\"/img/arrows.svg\">\n  </div>\n</div>\n\n<!-- ## Sharing Is Caring -->\n\n<p>\n  <!-- An advanced method of loading Google Fonts in the most efficient manner asynchronously to avoid render blocking and minimise the number of reflows. <br> -->\n  <span id=\"cc4dd\"><span class=\"d-inline-block\" style=\"height:36px\" data-loading>Loading sharing buttons...</span><noscript>Please enable JavaScript to Share</noscript></span>\n</p>\n    </div>\n  </div>\n</div>\n",
  "file": "./best-google-font-2",
  "postAjax": "(function imgPostAjax() {\n  /* eslint-env browser */\n  window['IO']()\n  window['WEBP']()\n})()"
}